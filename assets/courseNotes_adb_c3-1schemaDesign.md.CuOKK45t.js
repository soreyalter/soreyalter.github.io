import{_ as e,c as a,o,a4 as t}from"./chunks/framework.BBKq6QKo.js";const i="/adb/chap3.1/e2055a67acbfc1d025dfa2cbec084c40.png",l="/adb/chap3.1/3cefb0587aed59e852a5cd8aebf93097.png",r="/adb/chap3.1/d1cb76e8e177358fedc17d86420b3847.png",n="/adb/chap3.1/d2927bedb206b608539e707b56755010.png",s="/adb/chap3.1/fbf536e5054c4f81fd1c7ce961d23be9.png",c="/adb/chap3.1/deb9ef32b3201bd6458b313d973c9190.png",p="/adb/chap3.1/333c8deb03ea4d0239b24359e5a2130c.png",d="/adb/chap3.1/e00147e5e32fcbb20348b9069dd6532c.png",k=JSON.parse('{"title":"模式设计","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"courseNotes/adb/c3-1schemaDesign.md","filePath":"courseNotes/adb/c3-1schemaDesign.md"}'),h={name:"courseNotes/adb/c3-1schemaDesign.md"},g=t('<h1 id="模式设计" tabindex="-1">模式设计 <a class="header-anchor" href="#模式设计" aria-label="Permalink to &quot;模式设计&quot;">​</a></h1><blockquote><p>1、函数依赖的概念</p><p><strong>2、最小函数依赖集*</strong></p><p><strong>3、码的形式化定义*</strong></p><p><strong>4、1NF、2NF、3NF、BCNF*</strong></p><p><strong>5、无损并且保持函数依赖分解到3NF的算法*</strong></p><p>6、无损分解到BCNF的算法</p><p>————————</p><p>7、数据库设计过程以及各个过程的主要工作</p><p>8、ER设计的基本方法</p><p>9、逻辑设计的主要工作</p><p>10、ER模型到关系模型的转换方法</p></blockquote><h2 id="一、关系模式的分解" tabindex="-1">一、关系模式的分解 <a class="header-anchor" href="#一、关系模式的分解" aria-label="Permalink to &quot;一、关系模式的分解&quot;">​</a></h2><p>关系模式设计不规范会引起的问题（回顾第一章最后）</p><ul><li>数据冗余</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><h3 id="_1-1-模式分解概念" tabindex="-1">1.1 模式分解概念 <a class="header-anchor" href="#_1-1-模式分解概念" aria-label="Permalink to &quot;1.1 模式分解概念&quot;">​</a></h3><p><strong>概念</strong></p><ul><li>设有关系模式<code>R(U)和R1(U1), R2(U2), …, Rk(Uk)</code>，其中<code>U＝U1 ∪ U2 … ∪ Uk， 设 ρ＝{R1, R2,…, Rk}</code>，则称<code>ρ</code>为R的一个分解</li><li>理解模式分解的含义 <ul><li>属性集的分解</li><li>函数依赖集的分解</li></ul></li></ul><h3 id="_1-2-模式分解标准" tabindex="-1">1.2 模式分解标准 <a class="header-anchor" href="#_1-2-模式分解标准" aria-label="Permalink to &quot;1.2 模式分解标准&quot;">​</a></h3><ul><li>无损连接</li><li>保持函数依赖</li><li>既无损连接又保持函数依赖</li></ul><h4 id="_1-2-1-无损连接-lossless-join" tabindex="-1">1.2.1 无损连接(Lossless Join) <a class="header-anchor" href="#_1-2-1-无损连接-lossless-join" aria-label="Permalink to &quot;1.2.1 无损连接(Lossless Join)&quot;">​</a></h4><p><strong>概念和理解</strong></p><ul><li>设R是关系模式，分解成关系模式 <code>ρ＝{R1, R2,…, Rk}</code>，F是R上的一个FD集， 若对R中满足F的每个关系r，都有：<code>r＝ΠR1(r) ⋈ ΠR2(r) ⋈ … ⋈ ΠRk(r)</code>, 则 称这个分解<code>ρ</code>相对于F是“无损连接分解”</li><li>R的每个关系r是它在Ri上的投影的自然联接</li><li>无损连接保证R分解后还可以通过Ri恢复（最直观理解）</li></ul><p><img src="'+i+'" alt="image.png"></p><p><strong>无损连接的测试</strong></p><p>分解为两个关系模式的情形。直观理解就是交集要含有F左边的属性集，这样交集可以决定除去交集剩余部分的属性。</p><p><img src="'+l+'" alt="image.png"></p><p>R分解成n (n &gt; 2) 个关系模式的情形：Chase方法，参考《数据库系统概念》</p><h4 id="_1-2-2-保持函数依赖-preserve-dependency" tabindex="-1">1.2.2 保持函数依赖(Preserve Dependency) <a class="header-anchor" href="#_1-2-2-保持函数依赖-preserve-dependency" aria-label="Permalink to &quot;1.2.2 保持函数依赖(Preserve Dependency)&quot;">​</a></h4><p><strong>形式化定义</strong></p><p>直观理解就是把属性集分成几块不会把函数依赖中间的箭头<code>→</code>扯断</p><p><img src="'+r+'" alt="image.png"></p><p>不保持函数依赖会造成的问题：<strong>语义完整性被破坏</strong></p><p>（直观理解就是丢失了一个FD导致FD包含的语义（依赖关系）没了）</p><p><img src="'+n+'" alt="image.png"></p><h2 id="二、关系模式的范式" tabindex="-1">二、关系模式的范式 <a class="header-anchor" href="#二、关系模式的范式" aria-label="Permalink to &quot;二、关系模式的范式&quot;">​</a></h2><p><strong>范式概念</strong>：满足特定要求的模式</p><ul><li>不同级别的范式要求各不相同</li><li>范式可以作为衡量一个关系模式好坏的标准</li><li>若关系模式R满足范式xNF，记<code>R∈xNF（用属于“∈”表示）</code></li></ul><p><strong>规范化</strong>：将低一级范式的关系模式通过模式分解转 换为高一级范式的关系模式集合的过程</p><p>函数依赖图（不知道用来干嘛的先放在这）</p><h3 id="关系模式范式级别" tabindex="-1">关系模式范式级别 <a class="header-anchor" href="#关系模式范式级别" aria-label="Permalink to &quot;关系模式范式级别&quot;">​</a></h3><h4 id="_1nf" tabindex="-1">1NF <a class="header-anchor" href="#_1nf" aria-label="Permalink to &quot;1NF&quot;">​</a></h4><p><strong>定义</strong>：对于关系模式R的任一实例，其元组的<strong>每一个 属性值都只含有一个值</strong>，则R∈1NF</p><p>1NF是关系的基本要求</p><h4 id="_2nf" tabindex="-1">2NF <a class="header-anchor" href="#_2nf" aria-label="Permalink to &quot;2NF&quot;">​</a></h4><p><strong>定义</strong></p><ul><li>当且仅当R属于1NF，且R的每一个<strong>非主属性 都完全函数依赖于主码</strong>时，R∈2NF</li><li>注意是完全依赖，若主码中的部分属性就能决定一个非主属性（<strong>非主属性</strong>局部依赖于主码）也不满足2NF</li><li><strong>主属性</strong>可以局部依赖于主码</li></ul><p><strong>完全函数依赖</strong>：对于函数依赖<code>W→A</code>，若不存在<code>X⊂W</code>，并且<code>X→A</code>成立，则称<code>W→A</code>为完全函数依赖，否则为局部函数依赖</p><p><strong>例子</strong>：供应关系</p><p><code>R(S＃, P＃, city, status, Price, QTY)</code></p><p><code>F={S## → city, S## → status , P## → Price, city → status, {S#,P#} → QTY }</code></p><p><img src="'+s+'" alt="image.png"></p><p>模式分解到2NF：不扯断函数依赖，把局部依赖关系自己划成一个模式。</p><h4 id="_3nf" tabindex="-1">3NF <a class="header-anchor" href="#_3nf" aria-label="Permalink to &quot;3NF&quot;">​</a></h4><p><strong>定义</strong></p><ul><li>当且仅当R属于2NF，且R的每一个<strong>非主属性 都不传递依赖于主码主属性</strong>时，<code>R∈3NF</code></li><li>等效理解为不允许《非主属性》到《非码》的FD？<strong>不应该是《非码》到《非主属性》的FD吗（网上查到非码属性就是非主属性）</strong></li></ul><p><strong>传递依赖</strong>：若<code>Y→X</code>，<code>X→A</code>，并且<code>X→Y</code>，A不是X 的子集，则称A传递依赖于Y</p><p>2NF分解到3NF：去掉传递依赖</p><h4 id="bcnf" tabindex="-1">BCNF <a class="header-anchor" href="#bcnf" aria-label="Permalink to &quot;BCNF&quot;">​</a></h4><p><strong>BCNF的观点</strong></p><ul><li>2NF和3NF <ul><li>假设了R只有一个候选码，但一般情况下R可能有多个候选 码，并且不同的候选码之间还可能相互重叠</li><li>只考虑了非主属性到码的函数依赖</li></ul></li><li>BCNF扩充了3NF，可以处理R有多个候选码的情形 <ul><li>进一步考虑了主属性到码的函数依赖</li><li>进一步考虑了主属性对非主属性的函数依赖</li></ul></li></ul><p><strong>定义</strong></p><ul><li>（C.J. Date）如果关系模式R的所有<strong>不平凡的、完 全的函数依赖</strong>的决定因素（<strong>左边的属性集）都是候 选码</strong>，则R∈BCNF</li><li>（萨 &amp; 王）关系模式<code>R ∈1NF</code>，若R中的<strong>任一函数 依赖<code>X → Y</code>且 <code>Y !⊆ X</code> 时X必包含候选码</strong>，则R∈BCNF</li></ul><p>3NF：不允许非主属性到非码的FD，但允许主属性到其它 属性的FD（“X到Y的FD” = <code>Y → X</code> ？？）</p><p>BCNF：不允许主属性、非主属性到非码的FD</p><p>人话就是，<strong>函数依赖左边必然都是码</strong></p><p>分解到BCNF不一定能保持函数依赖</p><h2 id="三、模式分解的算法" tabindex="-1">三、模式分解的算法 <a class="header-anchor" href="#三、模式分解的算法" aria-label="Permalink to &quot;三、模式分解的算法&quot;">​</a></h2><h3 id="_3-1-保持函数依赖地分解到3nf的算法" tabindex="-1">3.1 保持函数依赖地分解到3NF的算法 <a class="header-anchor" href="#_3-1-保持函数依赖地分解到3nf的算法" aria-label="Permalink to &quot;3.1 保持函数依赖地分解到3NF的算法&quot;">​</a></h3><ol><li>求出最小依赖集F</li><li>把F涉及的属性划到一边R，没涉及的划另一边R&#39;</li><li>把R中属性按F左边相同的分组，把子集去掉。剩下的加上R&#39;就是结果</li></ol><p><img src="'+c+'" alt="image.png"></p><p><img src="'+p+'" alt="image.png"></p><h3 id="_3-2-无损并且保持函数依赖分解为3nf的算法" tabindex="-1">3.2 无损并且保持函数依赖分解为3NF的算法 <a class="header-anchor" href="#_3-2-无损并且保持函数依赖分解为3nf的算法" aria-label="Permalink to &quot;3.2 无损并且保持函数依赖分解为3NF的算法&quot;">​</a></h3><ol><li>首先用算法1求出R的保持函数依赖的3NF 分解，设为q={R1,R2,…,Rk} ===&gt; 已经得到保持依赖的3NF</li><li>设X是R的码，求出<code>p=q ∪{R(X)}</code></li><li>若X是q中某个Ri的子集，则在p中去掉R(X)</li><li>得到的p就是最终结果</li></ol><p>人话：在保持函数依赖的3NF模式中，若主码模式R(X)还没被某个模式包含，就加上去</p><h3 id="_3-3-无损分解为bcnf的算法" tabindex="-1">3.3 无损分解为BCNF的算法 <a class="header-anchor" href="#_3-3-无损分解为bcnf的算法" aria-label="Permalink to &quot;3.3 无损分解为BCNF的算法&quot;">​</a></h3><p>不用先确认模式R是不是已经符合2NF或者3NF，没有前置要求，直接一步到位从1NF变成BCNF</p><p><img src="'+d+'" alt="image.png"></p>',68),b=[g];function u(F,_,R,N,m,f){return o(),a("div",null,b)}const P=e(h,[["render",u]]);export{k as __pageData,P as default};
