import{_ as l,c as a,o as i,a4 as e}from"./chunks/framework.BGthqKqN.js";const t="/adb/chap7/d34758f741247b2d609e4503fb8f4dc7.png",r="/adb/chap7/6d34ec1ea78528f52a4f970efd8bfcef.png",o="/adb/chap7/80c630a7e1a18a776cf2d4b3ecc88068.png",n="/adb/chap7/9bb2cd53dab8b429fdb9e6fbb566d911.png",s="/adb/chap7/57416017e6197d7d81f836a1ce0a8ee6.png",h="/adb/chap7/f84d2491cf5006555f5516deb20778c9.png",k=JSON.parse('{"title":"索引结构","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"courseNotes/adb/c7indexStructure.md","filePath":"courseNotes/adb/c7indexStructure.md"}'),c={name:"courseNotes/adb/c7indexStructure.md"},u=e('<h1 id="索引结构" tabindex="-1">索引结构 <a class="header-anchor" href="#索引结构" aria-label="Permalink to &quot;索引结构&quot;">​</a></h1><blockquote><p><strong>复习提纲</strong></p><p>1、顺序文件上的索引：密集索引和稀疏索引</p><p>2、非顺序文件上的辅助索引</p><p>3、散列表、动态散列*</p><p>4、B+ Tree*</p></blockquote><h2 id="顺序文件的索引" tabindex="-1">顺序文件的索引 <a class="header-anchor" href="#顺序文件的索引" aria-label="Permalink to &quot;顺序文件的索引&quot;">​</a></h2><p>索引的功能：<strong>查找键 → 页号</strong></p><p>顺序文件：记录按查找键排序（一般就是<strong>主键</strong>了）</p><ul><li><strong>密集索引</strong><ul><li>每个记录都有一个索引项 ，索引项按查找键排序</li><li>记录通常比索引项要大（假设）</li><li>索引可以常驻内存 ==&gt; 占用空间大</li><li>要查找键值为K的记录是否存在，不需要访问 磁盘数据块</li></ul></li><li><strong>稀疏索引</strong><ul><li>仅部分记录有索引项， 一般情况下为每个数据块的第一个记录建立 索引</li><li>同样的记录可以使用更少的索引项，节省了索引空间</li><li>确认是否存在键值为K的记录需要访问磁 盘数据块</li></ul></li><li><strong>多级索引</strong><ul><li>一级索引可能还太大而不能常驻内存</li><li>二级索引更小，可以常驻内存</li><li>减少磁盘I/O次数</li><li>维护二级索引结构代价大</li></ul></li></ul><h2 id="非顺序文件的辅助索引" tabindex="-1">非顺序文件的辅助索引 <a class="header-anchor" href="#非顺序文件的辅助索引" aria-label="Permalink to &quot;非顺序文件的辅助索引&quot;">​</a></h2><ul><li>数据文件不需要按查找键有序（一般是主键之外的属性）</li><li>根据索引值不能确定记录在文件中的顺序</li><li>辅助索引只能是密集索引</li></ul><h3 id="重复键值的情形——间接桶" tabindex="-1">重复键值的情形——间接桶 <a class="header-anchor" href="#重复键值的情形——间接桶" aria-label="Permalink to &quot;重复键值的情形——间接桶&quot;">​</a></h3><ul><li>仍然采用密集索引的方法浪费空间，引入间接桶机制</li><li>间接桶就是在辅助索引和数据文件之间的一种类似二级索引的指针表</li></ul><p><img src="'+t+'" alt="image.png"></p><h3 id="倒排索引" tabindex="-1">倒排索引 <a class="header-anchor" href="#倒排索引" aria-label="Permalink to &quot;倒排索引&quot;">​</a></h3><ul><li>应用于文档检索，与辅助索引思想类似</li><li>不同之处 <ul><li>记录→文档</li><li>记录查找→文档检索</li><li>查找键→文档中的词</li></ul></li><li>思想 <ul><li>为每个检索词建立间接桶</li><li>桶的指针指向检索词所出现的文档</li></ul></li></ul><p><img src="'+r+'" alt="image.png"></p><p><img src="'+o+'" alt="image.png"></p><h2 id="b-树" tabindex="-1">B+树 <a class="header-anchor" href="#b-树" aria-label="Permalink to &quot;B+树&quot;">​</a></h2><ul><li>一种树型的多级索引结构</li><li>树的层数与数据大小相关，通常为3层</li><li>所有结点格式相同：n个值，n＋1个指针</li><li>所有叶结点位于同一层</li></ul><h3 id="叶结点" tabindex="-1">叶结点 <a class="header-anchor" href="#叶结点" aria-label="Permalink to &quot;叶结点&quot;">​</a></h3><p><img src="'+n+'" alt="image.png"></p><h3 id="非叶结点" tabindex="-1">非叶结点 <a class="header-anchor" href="#非叶结点" aria-label="Permalink to &quot;非叶结点&quot;">​</a></h3><p>若树中结点最多含有n个关键字，则每个分支结点至少有 ⌈(n+1)/2⌉ 棵子树（n+1 即B+树的阶）</p><p>区间划分左闭右开</p><p><img src="'+s+'" alt="image.png"></p><h3 id="插入" tabindex="-1">插入 <a class="header-anchor" href="#插入" aria-label="Permalink to &quot;插入&quot;">​</a></h3><ul><li>查找插入叶结点</li><li>若叶结点中有空闲位置（键），则插入</li><li>若没有空间，则分裂叶结点 <ul><li>叶结点的分裂可视作是父结点中插入一个子结点</li><li>递归向上分裂，非叶结点的分裂会将本层的一个键值移动到上一层</li><li>分裂过程中需要对父结点中的键加以调整</li><li>例外：若根结点分裂，则需要创建一个新的根结 点</li></ul></li></ul><p><img src="'+h+'" alt="image.png"></p><h3 id="删除" tabindex="-1">删除 <a class="header-anchor" href="#删除" aria-label="Permalink to &quot;删除&quot;">​</a></h3><p>查找要删除的键值，并删除之。</p><p>若结点的键值填充低于最低规定值，则调整：</p><ul><li>隔壁有多的元素：若相邻的叶结点中键填充高于最低规定值，则将其中 一个键值移到该结点中</li><li>隔壁没有多的元素：合并该结点与相邻结点 <ul><li>合并可视作在父结点中删除一个子结点</li></ul></li><li>递归向上删除 若删除的是叶结点中的最小键值，则需对父 结点的键值加以调整</li></ul><h3 id="b-树的效率" tabindex="-1">B+树的效率 <a class="header-anchor" href="#b-树的效率" aria-label="Permalink to &quot;B+树的效率&quot;">​</a></h3><ul><li>访问索引的I/O代价＝树高（B＋树不常驻内 存）或者0（常驻内存）</li><li>树高通常不超过3层，因此索引I/O代价不超 过3（总代价不超过4读取记录）</li><li>通常情况下，根节点常驻内存，因此索引I/O代 价不超过2（总代价不超过3）</li></ul><h2 id="散列索引" tabindex="-1">散列索引 <a class="header-anchor" href="#散列索引" aria-label="Permalink to &quot;散列索引&quot;">​</a></h2><ul><li>对于给定的散列键值k，计算h(K)</li><li>根据h(K)定位桶</li><li>查找桶中的块</li></ul><p><strong>插入删除</strong>：考虑溢出块</p><p>空间利用率 = 实际键值数 / 所有桶可放置的键值数</p><h3 id="动态散列表" tabindex="-1">动态散列表 <a class="header-anchor" href="#动态散列表" aria-label="Permalink to &quot;动态散列表&quot;">​</a></h3><h4 id="可扩展散列表-extensible-hash-tables" tabindex="-1">可扩展散列表（Extensible Hash Tables） <a class="header-anchor" href="#可扩展散列表-extensible-hash-tables" aria-label="Permalink to &quot;可扩展散列表（Extensible Hash Tables）&quot;">​</a></h4><p><strong>机制</strong></p><ul><li>散列函数值h(k)是一个b(足够大)位二进制序列 ，前 i 位表示桶的桶号。</li><li>i 的值随数据文件的增长而增大，导致成倍增加桶数目</li></ul><p><strong>优点</strong></p><ul><li>当查找记录时，只需查找一个存储块。</li></ul><p><strong>缺点</strong></p><ul><li>桶增长速度快，可能会导致内存放不下整个 桶数组，影响其他保存在主存中的数据，波 动较大。</li></ul><h4 id="线性散列表-linear-hash-tables" tabindex="-1">线性散列表（Linear Hash Tables） <a class="header-anchor" href="#线性散列表-linear-hash-tables" aria-label="Permalink to &quot;线性散列表（Linear Hash Tables）&quot;">​</a></h4><p><strong>机制</strong></p><ul><li>h(k)仍是二进制位序列，但使用右边（低）i 位 区分桶</li><li>桶数＝n，h(k)的右 i 位＝m</li><li>若m &lt; n，则记录位于第m个桶</li><li>若n ≤ m &lt; 2i，则记录位于第 m- 2^(i - 1) 个桶</li><li>n的选择：总是使n与当前记录总数r保持某个固定 比例</li><li>意味着只有当桶的填充度达到超过某个比例后桶数才开 始增长</li></ul><p><strong>看作业习题</strong></p>',48),d=[u];function p(b,g,m,_,f,q){return i(),a("div",null,d)}const P=l(c,[["render",p]]);export{k as __pageData,P as default};
