import{_ as s,c as i,o as a,a4 as t}from"./chunks/framework.BGthqKqN.js";const g=JSON.parse('{"title":"项目收获","description":"","frontmatter":{"title":"项目收获","outline":"deep"},"headers":[],"relativePath":"selfstudyNotes/frontend/uniappProjectNotes.md","filePath":"selfstudyNotes/frontend/uniappProjectNotes.md"}'),n={name:"selfstudyNotes/frontend/uniappProjectNotes.md"},p=t(`<h1 id="前端项目收获" tabindex="-1">前端项目收获 <a class="header-anchor" href="#前端项目收获" aria-label="Permalink to &quot;前端项目收获&quot;">​</a></h1><h2 id="typescript-项目" tabindex="-1">TypeScript 项目 <a class="header-anchor" href="#typescript-项目" aria-label="Permalink to &quot;TypeScript 项目&quot;">​</a></h2><h3 id="为什么要使用-typescript" tabindex="-1">为什么要使用 Typescript <a class="header-anchor" href="#为什么要使用-typescript" aria-label="Permalink to &quot;为什么要使用 Typescript&quot;">​</a></h3><p>项目使用 TypeScript 的好处在于：</p><ul><li>编写代码时有属性提示，这让开发过程更加安全高效</li><li>IDE 静态分析和编译类型校验</li></ul><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>小型项目中 ts 的类型提示作用不大，因为数据的结构并不复杂。</p><p>在本项目中后端返回的数据中，有包括页码数据、商品数据、用户信息等杂糅在一起的复杂结构，这种情况下如果没有类型提示，前端开发人员很容易搞不清楚数据的归属和其语义.</p></div><h3 id="typescript-类型声明" tabindex="-1">Typescript 类型声明 <a class="header-anchor" href="#typescript-类型声明" aria-label="Permalink to &quot;Typescript 类型声明&quot;">​</a></h3><p>使用 ts 需要配置 .tsconfig 文件，在其中声明编译选项等。</p><p>比如，在 uniapp 项目中，需要在其中配置类型声明文件：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// tsconfig.json</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;types&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;@dcloudio/types&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// uni-app API 类型</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;miniprogram-api-typings&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原生微信小程序类型</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;@uni-helper/uni-app-types&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// uni-app 组件类型</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;@uni-helper/uni-ui-types&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // uni-ui 组件类型  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // vue 编译器类型，校验标签类型</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;vueCompilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;nativeTags&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;block&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;component&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;template&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;slot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>而业务代码的类型声明文件，可以在 /src/types 中存放，后缀一般为 .d.ts. 使用时导入该声明文件即可：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { AddressDetail, AddressParams } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/types/address&#39;</span></span></code></pre></div><h3 id="坑" tabindex="-1">坑 <a class="header-anchor" href="#坑" aria-label="Permalink to &quot;坑&quot;">​</a></h3><p>使用 vue3 响应式声明一个对应类型的对象，以接收从后端返回的数据，这是非常常见的用法。 如果这个数据与表单数据双向绑定，注意其初始化状态。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark has-diff vp-code" tabindex="0"><code><span class="line diff add"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> profileData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProfileRusult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line diff remove"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> profileData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ProfileRusult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()  </span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>获取用户个人信息，修改个人信息时要修改这个数据。v-model必须能访问到，所以必须要有初始值，不能直接那样直接写 <code>ref&lt;result&gt;()</code>初始化一个空对象。不然会报错。</p></div><h2 id="全局状态管理-pinia" tabindex="-1">全局状态管理 - Pinia <a class="header-anchor" href="#全局状态管理-pinia" aria-label="Permalink to &quot;全局状态管理 - Pinia&quot;">​</a></h2><h3 id="vuex-和-pinia" tabindex="-1">VueX 和 Pinia <a class="header-anchor" href="#vuex-和-pinia" aria-label="Permalink to &quot;VueX 和 Pinia&quot;">​</a></h3><p>Vuex 主要包含以下几个核心概念：</p><ul><li>State：用于存储全局状态。</li><li>Getter：用于从 State 中派生出一些状态，例如计算属性。</li><li>Mutation：用于同步修改 State，严格遵循单向数据流。</li><li>Action：用于异步操作，可以包含异步 API 请求、异步提交 Mutation 等。</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>在 VueX 中修改 state 的唯一方式就是显式地提交 mutation，虽然可以直接对其赋值修改，但 vuex 跟踪不到这个变化。</p></div><p>Pinia 可以理解为就是 Vuex5，是一个轻量级的、兼容 Vue 3 和 Vue 2 的状态管理库。Pinia 和 VueX 主要区别是废弃了经常被认为是极其冗余的 mutation。可以创建和使用多个 Store 实例，每个 Store 都有自己独立的状态和方法。</p><h3 id="持久化" tabindex="-1">持久化 <a class="header-anchor" href="#持久化" aria-label="Permalink to &quot;持久化&quot;">​</a></h3><p>pinia-plugin-persistedstate 插件实现持久化，这个插件默认使用 localStorage 实现持久化。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createPinia } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;pinia&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> persist </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;pinia-plugin-persistedstate&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pinia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createPinia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pinia.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(persist)</span></span></code></pre></div><p>小程序端不兼容，所以必须自定义修改插件配置，这里存储数据必须是同步的。</p><blockquote><p><strong>storage</strong></p><ul><li>类型：StorageLike</li><li>默认值：localStorage</li></ul><p>将数据持久化到 storage 中，必须具有 <code>getItem: (key: string) =&gt; string | null</code> 和 <code>setItem: (key: &gt; string, value: string) =&gt; void</code> 两个方法。</p></blockquote><p>uni-app 支持多端的持久化 API是 <code>uni.setStorageSync()</code>和<code>uni.getStorageSync()</code>。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// persist: true,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    persist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 默认只有网页端的 getter 和 setter</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 必须提供小程序对应的 storage.setItem, storage.getItem 接口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      storage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, value) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          uni.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setStorageSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uni.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getStorageSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span></code></pre></div><p>持久化存储配置完成后，就会自动将用户数据保存在客户端，即使用户关闭了小程序，数据依然可以保留。</p>`,30),e=[p];function l(h,k,r,d,o,c){return a(),i("div",null,e)}const u=s(n,[["render",l]]);export{g as __pageData,u as default};
