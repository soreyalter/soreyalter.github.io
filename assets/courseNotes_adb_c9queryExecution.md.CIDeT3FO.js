import{_ as a,c as i,o as e,a4 as l}from"./chunks/framework.BGthqKqN.js";const t="/adb/chap9/14d3766c3d247497f73eaac1b8e94c1f.png",r="/adb/chap9/24a8cd3a89a003fbeb43079693ec2ed5.png",o="/adb/chap9/1479b7764541584411a0aca0086ad45e.png",n="/adb/chap9/5919d0650269ed760300d92b294ce3cd.png",c="/adb/chap9/d69e4bdaa551336fe819cd5b5775a328.png",p="/adb/chap9/a5811d3095f54c09819570c069e06d2b.png",s="/adb/chap9/8a677c7268bd6253ee43963b9a4397b8.png",h="/adb/chap9/292be3240cf97ff56b9d03e027df9199.png",d="/adb/chap9/237a2a702024c7eaf1de58be32563474.png",u="/adb/chap9/b9f2c720b3b4e8e38a9c335477be92e9.png",g="/adb/chap9/9184200443ce760279a18f7fa4cd8556.png",b="/adb/chap9/17df0c8e5702c5f47865ba3b546ae16b.png",m="/adb/chap9/4b6543ffad2b89c7fef374a0310680ae.png",_="/adb/chap9/ca4e42a06d3c87d1de93340f2ea54e63.png",f="/adb/chap9/8032354c032725c56f6e9f7ac08295c4.png",q="/adb/chap9/28fc6e83690dd6ea470bfb7586d6a277.png",R="/adb/chap9/61a56d62d866d5e179fda39b2c67dcaa.png",k="/adb/chap9/58d5177164d65265efd54af751cc49ad.png",x="/adb/chap9/7b165f8b671a961c9c5345e0315ec412.png",B=JSON.parse('{"title":"查询执行","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"courseNotes/adb/c9queryExecution.md","filePath":"courseNotes/adb/c9queryExecution.md"}'),P={name:"courseNotes/adb/c9queryExecution.md"},I=l('<h1 id="查询执行" tabindex="-1">查询执行 <a class="header-anchor" href="#查询执行" aria-label="Permalink to &quot;查询执行&quot;">​</a></h1><blockquote><p><strong>复习提纲</strong></p><p>1、嵌套循环连接</p><p>2、归并连接</p><p>3、索引连接</p><p>4、散列连接</p><p><strong>5、连接算法的I/O代价估计与内存开销*</strong></p></blockquote><h2 id="物理查询计划操作符" tabindex="-1">物理查询计划操作符 <a class="header-anchor" href="#物理查询计划操作符" aria-label="Permalink to &quot;物理查询计划操作符&quot;">​</a></h2><ul><li>逻辑操作符的物理操作符 <ul><li>逻辑操作符的特定实现</li></ul></li><li>其它物理操作符 <ul><li>表扫描：TableScan</li><li>排序扫描：SortScan</li><li>索引扫描：IndexScan</li></ul></li></ul><p><img src="'+t+'" alt="image.png"></p><h2 id="连接操作的实现算法" tabindex="-1">连接操作的实现算法（*） <a class="header-anchor" href="#连接操作的实现算法" aria-label="Permalink to &quot;连接操作的实现算法（\\*）&quot;">​</a></h2><h3 id="嵌套循环连接" tabindex="-1">嵌套循环连接 <a class="header-anchor" href="#嵌套循环连接" aria-label="Permalink to &quot;嵌套循环连接&quot;">​</a></h3><p>暴力遍历算法</p><h3 id="归并连接" tabindex="-1">归并连接 <a class="header-anchor" href="#归并连接" aria-label="Permalink to &quot;归并连接&quot;">​</a></h3><ul><li>若无序先排序，这里按升序排序</li><li>在暴力遍历的基础上，通过排序使得R2的指针不回退</li><li>因为可能有重复值，输出元组的算法要特别别注意</li></ul><p><img src="'+r+'" alt="image.png"></p><p><img src="'+o+'" alt="image.png"></p><h3 id="索引连接" tabindex="-1">索引连接 <a class="header-anchor" href="#索引连接" aria-label="Permalink to &quot;索引连接&quot;">​</a></h3><p>对于R1的每个值，用索引来找到R2中对应属性与它相等的元组集，拼接即可输出</p><p><img src="'+n+'" alt="image.png"></p><h3 id="散列连接" tabindex="-1">散列连接 <a class="header-anchor" href="#散列连接" aria-label="Permalink to &quot;散列连接&quot;">​</a></h3><p>使用<strong>同样的哈希函数</strong>，且若能保证不同键值的桶一定不相同，那么下标相同的桶中的键值是一样的，可以通过全组合拼接出输出元组；若不同键值放在同一个桶中，仍然需要遍历匹配。</p><p><img src="'+c+'" alt="image.png"></p><h2 id="连接算法的i-o代价估计" tabindex="-1">连接算法的I/O代价估计 <a class="header-anchor" href="#连接算法的i-o代价估计" aria-label="Permalink to &quot;连接算法的I/O代价估计&quot;">​</a></h2><p><strong>影响连接算法代价(I/O)的因素</strong></p><ul><li>关系的元组是否在磁盘块中连续存放？ (contiguous?)</li><li>关系是否按连接属性有序？ (ordered?)</li><li>连接属性上是否存在索引？ (indexed?)</li></ul><h3 id="嵌套循环连接代价" tabindex="-1">嵌套循环连接代价 <a class="header-anchor" href="#嵌套循环连接代价" aria-label="Permalink to &quot;嵌套循环连接代价&quot;">​</a></h3><h4 id="元组不连续存放" tabindex="-1">元组不连续存放 <a class="header-anchor" href="#元组不连续存放" aria-label="Permalink to &quot;元组不连续存放&quot;">​</a></h4><p>元组可能分散在完全不同的块里，元组数 = 块数</p><p><strong>暴力遍历</strong></p><ul><li>每个元组都放在不同的块里，所以每次访问一个元组都要读一次</li><li>IO代价 = R1元组数 * ( 1 + R2元组数 )</li></ul><p><strong>改进的策略</strong></p><ul><li>暴力算法中R2的每个元组都被读入内存中 T(R1) 次进行匹配</li><li>空间换时间，将R1元组尽可能读入内存中，R2元组每次进入内存可以与1000条R1的元组匹配，只需读入10次</li><li>进一步改善：交换R1，R2的连接顺序，让少的在左边</li></ul><p><img src="'+p+'" alt="image.png"></p><h4 id="元组连续存放" tabindex="-1">元组连续存放 <a class="header-anchor" href="#元组连续存放" aria-label="Permalink to &quot;元组连续存放&quot;">​</a></h4><p>用上述的改进算法思想，每一轮读100个R2的块进内存和每个R1的记录进行匹配</p><p><img src="'+s+'" alt="image.png"></p><h3 id="归并连接代价" tabindex="-1">归并连接代价 <a class="header-anchor" href="#归并连接代价" aria-label="Permalink to &quot;归并连接代价&quot;">​</a></h3><h4 id="连续存放" tabindex="-1">连续存放 <a class="header-anchor" href="#连续存放" aria-label="Permalink to &quot;连续存放&quot;">​</a></h4><p>已排序的情形</p><p><img src="'+h+'" alt="image.png"></p><p>未排序则先排序</p><p>排序方法：两阶段多路归并</p><ul><li>第一阶段：尽可能多的块读入内存中并排序成chunk，写回磁盘（图中一个chunk是100个块那么大）</li><li>按<strong>外部归并排序</strong>将多个chunk归并，缓存中每次比较产生一个最小元组写回磁盘</li></ul><p><img src="'+d+'" alt="image.png"></p><p><img src="'+u+'" alt="image.png"></p><h5 id="代价分析" tabindex="-1">代价分析 <a class="header-anchor" href="#代价分析" aria-label="Permalink to &quot;代价分析&quot;">​</a></h5><ul><li>排序代价：每个元组均被读入两次，写回两次，四次I/O</li><li>归并和连接代价：每个元组读入一次，一次I/O</li></ul><p><strong>归并连接和嵌套循环连接的比较</strong></p><p><img src="'+g+'" alt="image.png"></p><h5 id="内存需求" tabindex="-1">内存需求 <a class="header-anchor" href="#内存需求" aria-label="Permalink to &quot;内存需求&quot;">​</a></h5><p><img src="'+b+'" alt="image.png"></p><h5 id="归并连接算法的改进" tabindex="-1">归并连接算法的改进 <a class="header-anchor" href="#归并连接算法的改进" aria-label="Permalink to &quot;归并连接算法的改进&quot;">​</a></h5><ul><li><strong>使用条件：R1 chunks + R2 chunks &lt;= M</strong></li><li>第一阶段将记录排序为chunk不变</li><li>第二阶段排序和join一起进行 <ul><li>每次需要将R1和R2的各一个块读入</li></ul></li></ul><p><img src="'+m+'" alt="image.png"></p><p>这样每个元组只需3次I/O</p><p>chunk还没归并怎么实现join的？？—— R1 chunks + R2 chunks &lt;= M</p><p><img src="'+_+'" alt="image.png"></p><h3 id="索引连接代价" tabindex="-1">索引连接代价 <a class="header-anchor" href="#索引连接代价" aria-label="Permalink to &quot;索引连接代价&quot;">​</a></h3><p><strong>假设</strong></p><ul><li>R1.C 建立了索引</li><li>R1.C 的索引在内存中</li><li>R2 记录连续存放，未排序</li></ul><p><img src="'+f+'" alt="image.png"></p><h4 id="代价分析-1" tabindex="-1">代价分析 <a class="header-anchor" href="#代价分析-1" aria-label="Permalink to &quot;代价分析&quot;">​</a></h4><ul><li>读入R2的每个元组 = 500次I/O</li><li>查内存中R1的索引 = 0次I/O</li><li>若有匹配的记录则读入内存中join，I/O次数考虑选中率 <ul><li>若R1.C是主键, R2.C是外键,则 每个R2 tuple在R1中,选中率 p =1</li><li>若V(R1,C)=5,000, T(R1) = 10,000, 则 每个R2 tuple在R1中的选中率 p = T(R1)/V(R1,C)=2</li></ul></li></ul><h4 id="若r1的索引不能全部读入内存中" tabindex="-1">若R1的索引不能全部读入内存中 <a class="header-anchor" href="#若r1的索引不能全部读入内存中" aria-label="Permalink to &quot;若R1的索引不能全部读入内存中&quot;">​</a></h4><ul><li>读入：所有的2级索引块 + 尽量多的1级索引块</li><li>若对应记录的1级索引块在内存中，则I/O次数 = 0，否则多一次I/O</li></ul><p><img src="'+q+'" alt="image.png"></p><h3 id="散列连接代价" tabindex="-1">散列连接代价 <a class="header-anchor" href="#散列连接代价" aria-label="Permalink to &quot;散列连接代价&quot;">​</a></h3><p>连续存放且未排序，100个桶</p><p><img src="'+R+'" alt="image.png"></p><h4 id="代价分析-2" tabindex="-1">代价分析 <a class="header-anchor" href="#代价分析-2" aria-label="Permalink to &quot;代价分析&quot;">​</a></h4><p>总共3次I/O</p><ul><li>R1读入，创建桶，写回</li><li>R2读入，创建桶，写回</li><li>读入R2一个桶，读入R1对应的桶并join</li></ul><h4 id="内存需求-1" tabindex="-1">内存需求 <a class="header-anchor" href="#内存需求-1" aria-label="Permalink to &quot;内存需求&quot;">​</a></h4><p>JOIN的需求：<strong>一个桶中的块数 + 1 &lt;= 内存块数</strong></p><p>近似：<strong>Min( B(R1), B(R2) ) &lt;= M^2</strong></p><p><img src="'+k+'" alt="image.png"></p><p><img src="'+x+'" alt="image.png"></p>',73),O=[I];function T(S,C,N,E,V,j){return e(),i("div",null,O)}const M=a(P,[["render",T]]);export{B as __pageData,M as default};
