import{_ as i,c as l,o as a,a4 as s}from"./chunks/framework.BGthqKqN.js";const n="/adb/chap6/f332f40d497e9bdece6e45e4a091552b.png",t="/adb/chap6/ed36517c3cc8913f461ad8032e78fc60.png",e="/adb/chap6/9d1a08fc8661c4a4cb62a8f1232d093b.png",r="/adb/chap6/75aef6a7499172ec22f3c307cd3e887f.png",b=JSON.parse('{"title":"缓冲管理","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"courseNotes/adb/c6bufferManagement.md","filePath":"courseNotes/adb/c6bufferManagement.md"}'),o={name:"courseNotes/adb/c6bufferManagement.md"},p=s('<h1 id="缓冲管理" tabindex="-1">缓冲管理 <a class="header-anchor" href="#缓冲管理" aria-label="Permalink to &quot;缓冲管理&quot;">​</a></h1><blockquote><p><strong>复习提纲</strong></p><p>1、缓冲区结构、frame/dirty/pin-count等概念的含义*</p><p>2、缓冲区置换算法*</p><p>3、缓冲区管理器的实现</p></blockquote><h2 id="缓冲区结构" tabindex="-1">缓冲区结构 <a class="header-anchor" href="#缓冲区结构" aria-label="Permalink to &quot;缓冲区结构&quot;">​</a></h2><p><strong>frame的参数</strong></p><p>frame是缓冲区的一行，能够存放若干个块（一般就是一对一），缓存换出以frame为单位，读入以块为单位</p><ul><li><strong>Dirty</strong>：Frame中的块是否已经<strong>被修改</strong></li><li><strong>Pin-count</strong>：Frame的块的已经<strong>被请求并且还未释放</strong>的计数 ，即当前的用户数 <ul><li>该标志位主要用于多进程读(不是读 写,因为读写会冲突)，计数大于等于0的frame不能被改写或释放.</li><li>该标识位主要用于非抢占的架构,即 各进程(用户)平权,如果可以抢占则对于某些优先级高的请求则可以无视Pin-count标志强制进行改写</li></ul></li><li>Others （<strong>Latch</strong>: 是否加锁）</li></ul><p><strong>请求块</strong></p><ul><li>目标块不在缓冲区 <ul><li>选择一个frame来置换</li><li>若 frame 为脏，写回磁盘</li><li>读入包含目标块并增加 Pin-count ，返回对应的地址</li></ul></li><li>目标块在缓冲区中 <ul><li>增加 pin-count并返回地址</li></ul></li></ul><p><strong>释放块</strong></p><ul><li>请求者必须释放包含块的frame的pin-count</li><li>请求者必须指明块是否被修改过</li></ul><h2 id="缓冲区置换算法" tabindex="-1">缓冲区置换算法 <a class="header-anchor" href="#缓冲区置换算法" aria-label="Permalink to &quot;缓冲区置换算法&quot;">​</a></h2><ul><li>只有pin-count = 0 的 frame 可以被置换</li><li>置换算法对I/O影响极大，取决于访问模式</li></ul><p><strong>理论最优算法</strong></p><ul><li>OPT 算法（Belady’s算法）</li><li>理论上最佳的页面置换算法。它每次都置换以后永远也用不到的 页面，如果没有则淘汰最久以后再用到的页面。</li><li>OPT算法必须预先知道全部的页面访问序列，而这在实际 DBMS/OS中是无法实现的，因此仅有理论意义。</li><li>在实验中作为算法性能上界加以对比</li></ul><p><strong>为何不使用 OS 缓冲区管理？</strong></p><ul><li>DBMS经常能预测访问模式(Access Pattern) <ul><li>可以使用更专门的缓冲区替换策略</li><li>有利于pre-fetch策略的有效使用</li></ul></li><li>DBMS需要<strong>强制写回磁盘能力</strong>（如WAL，写前日志） ，OS的缓冲写回一般通过记录写请求来实 现（来自不同应用），实际的磁盘修改推迟 ，因此不能保证写顺序</li></ul><h3 id="lru" tabindex="-1">LRU <a class="header-anchor" href="#lru" aria-label="Permalink to &quot;LRU&quot;">​</a></h3><p><img src="'+n+'" alt="image.png"></p><p><strong>优点</strong></p><ul><li>重复访问特定页时，该策略表现较好</li><li>只需要O(1)的时间选择被置换的frame</li></ul><p><strong>缺点</strong></p><ul><li><strong>缓存污染(Sequential flooding)</strong>：一次连续访问大量之后不会再重复访问的页面，会把原本的链表全部冲出内存</li><li>维护代价大：每次访问都会修改链表，而链表不支持随机访问</li><li>如果访问不满足时间局部性，则性能较差</li><li>只考虑最近一次访问，不考虑访问频率 —— 导致颠簸</li></ul><h3 id="lru-k" tabindex="-1">LRU-K <a class="header-anchor" href="#lru-k" aria-label="Permalink to &quot;LRU-K&quot;">​</a></h3><p>如果某个frame的访问次数达到了K次以上，则 应当尽量不置换</p><ul><li>维护2个LRU链表 <ul><li>访问次数小于K次的链表</li><li>访问次数K次以上的链表</li></ul></li><li>优先按照LRU策略置换 小于K次的链表</li><li>保证高频访问的页能够尽 量在buffer中</li></ul><p>实验表明 ：K并非越大越好，LRU-2 性能较好</p><p><strong>优点</strong>：在LRU的基础上考虑了访问频率</p><p><strong>缺点</strong>：需要额外记录访问次数；K链表上的页面可能后续不再访问，但难以置换出去（老化：每隔一段时间将访问次数减半）</p><p><img src="'+t+'" alt="image.png"></p><p>**LRU-2Q：**与LRU-2类似，不同之处在于访问1次的队列采 用FIFO，而不是LRU</p><h3 id="second-chance-fifo" tabindex="-1">Second-Chance FIFO <a class="header-anchor" href="#second-chance-fifo" aria-label="Permalink to &quot;Second-Chance FIFO&quot;">​</a></h3><p><img src="'+e+`" alt="image.png"></p><ul><li>相当于每个frame给了<strong>两次置换机会</strong>（复活一次），避免高频访问但最近一 轮没有被访问的frame被置换出buffer</li><li>若被置为1的frame再次被访问，将其访问位重新置为0</li><li>每个frame只需要1个额外bit，空间代价很低</li><li>缺点：置换时需要移动多个元素，理论性能比LRU差</li></ul><h3 id="clock" tabindex="-1">CLOCK <a class="header-anchor" href="#clock" aria-label="Permalink to &quot;CLOCK&quot;">​</a></h3><p>在second-chance基础上得到，为避免每次访问时的链表调整代价，将链表组织成环</p><ul><li>把Second-Chance FIFO组织成<strong>环形</strong></li><li><strong>current指针</strong>指向当前 frame；每个frame有一个 <strong>referenced</strong> 位，初始为1（而不是原本的0）</li><li>当需要置换页时，从current开始检查 <ul><li>若 <strong>pin-count &gt; 0</strong>，current增加1（正在被访问）</li><li>若 <strong>referenced = 1</strong>（已启动），则关闭它（= 0）并增加 current，保证 最近的不被替换（复活甲）</li><li>若 <strong>pin-count = 0</strong> <strong>且 referenced =0</strong>（关闭），则替换 该frame，同时 current 加1</li></ul></li><li>注意：Current指针<strong>只在置换时更新</strong>，访问<strong>命中时不改变Current指针</strong></li></ul><h3 id="ssd-置换算法" tabindex="-1">SSD 置换算法 <a class="header-anchor" href="#ssd-置换算法" aria-label="Permalink to &quot;SSD 置换算法&quot;">​</a></h3><p><strong>特点</strong>：读快写慢，写次数有限 ，<strong>减少缓存置换中对闪存的写</strong>是一 个重要指标</p><p>SSD-aware缓存算法</p><ul><li><strong>CFLRU</strong> (CASES’06，CASES’21 Test of Time Award) <ul><li>Clean-first</li></ul></li><li>LRU-WSR(IEEE Trans CE’08) <ul><li>Clean-first + cold flag（复活甲）</li><li>置换：clean &gt; cold dirty &gt; hot dirty</li></ul></li><li>AD-LRU (DKE’10) <ul><li>cold LRU list + hot LRU list</li><li>Dynamically adjust two LRUs</li></ul></li></ul><h2 id="缓冲区管理的实现" tabindex="-1">缓冲区管理的实现 <a class="header-anchor" href="#缓冲区管理的实现" aria-label="Permalink to &quot;缓冲区管理的实现&quot;">​</a></h2><p><strong>Buffer 中 Frame 的查找</strong></p><ul><li>读磁盘块时：根据page_id确定在Buffer 中是否已经存在frame</li><li>写磁盘块时：要根据frame_id快速找到文 件中对应的page_id</li></ul><ol><li>首先，要维护Buffer中所有frame的维护 信息（Buffer Control Blocks）</li></ol><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BCB {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> page_id;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frame_id;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> time;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* int latch; */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dirty;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    BCB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BCB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><ol start="2"><li>建立frame-page之间的索引 ，若用Hash Table，需要建立2个 <ul><li>BCB hTable[BufferSize] //page 2 frame</li><li>int hTable[BufferSize] //frame 2 page</li></ul></li></ol><p><img src="`+r+'" alt="image.png"></p>',47),c=[p];function h(g,u,d,f,k,m){return a(),l("div",null,c)}const _=i(o,[["render",h]]);export{b as __pageData,_ as default};
