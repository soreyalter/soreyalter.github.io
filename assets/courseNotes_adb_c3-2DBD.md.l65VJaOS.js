import{_ as l,c as i,o as a,a4 as r}from"./chunks/framework.BGthqKqN.js";const t="/adb/chap3.2/9706a1c0268fe5a914f61a8e4a5d31c8.png",o="/adb/chap3.2/34e847b862df712bf92065b3fe9ed353.png",e="/adb/chap3.2/3550a4d784defd1043defdfaa041243c.png",n="/adb/chap3.2/205f232e368da7fa9392cd29596d23c0.png",s="/adb/chap3.2/f0806918d43f2a6646d7b1d9cbf37ab6.png",u="/adb/chap3.2/318f8c9992167f84961d6d4b92e57294.png",p="/adb/chap3.2/fb324362fd0bc006b0c576d255f7abc9.png",g="/adb/chap3.2/7e73650591ec1d51f22a9312bc7c6576.png",c="/adb/chap3.2/8abe2c7d2b233cdeeed416d633e95654.png",d="/adb/chap3.2/91c763df9c1c28aa12fd0110c428a492.png",h="/adb/chap3.2/a1c68c475b19524261446f4af6dd1bda.png",b="/adb/chap3.2/11567542bd76672cc5e662f681b502c4.png",N=JSON.parse('{"title":"数据库设计","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"courseNotes/adb/c3-2DBD.md","filePath":"courseNotes/adb/c3-2DBD.md"}'),_={name:"courseNotes/adb/c3-2DBD.md"},m=r('<h1 id="数据库设计" tabindex="-1">数据库设计 <a class="header-anchor" href="#数据库设计" aria-label="Permalink to &quot;数据库设计&quot;">​</a></h1><h2 id="一、设计方法" tabindex="-1">一、设计方法 <a class="header-anchor" href="#一、设计方法" aria-label="Permalink to &quot;一、设计方法&quot;">​</a></h2><p>本课程指定设计方法</p><ul><li>以新奥尔良方法为基础，基于ER模型和关系模式， 采用计算机辅助进行数据库设计 <ul><li><strong>概念设计</strong>：基于<strong>ER模型</strong></li><li><strong>逻辑设计</strong>：基于<strong>关系模式</strong>设计</li><li>计算机辅助设计工具：PowerDesigner（SYBASE）</li></ul></li></ul><p><img src="'+t+'" alt="image.png"></p><h2 id="二、概念设计" tabindex="-1">二、概念设计 <a class="header-anchor" href="#二、概念设计" aria-label="Permalink to &quot;二、概念设计&quot;">​</a></h2><p>产生反映组织信息需求的数据库概念结构， 即概念模型。</p><ul><li>概念模型独立于数据库逻辑结构、DBMS以及计 算机系统</li><li>概念模型以一组ER图形式表示</li></ul><p>概念设计侧重于数据内容的分析和抽象，以用户的观点描述应用中的实体以及实体间的 联系。</p><h3 id="_2-1-er模型要素" tabindex="-1">2.1 ER模型要素 <a class="header-anchor" href="#_2-1-er模型要素" aria-label="Permalink to &quot;2.1 ER模型要素&quot;">​</a></h3><p><strong>实体</strong>（Entity） ：包含实体属性</p><ul><li>现实世界中可标识的对象</li><li>应用中的数据以实体的形式呈现</li><li>一个实体具有唯一的标识，称为码（Key）</li></ul><p><strong>联系</strong>（Relationship） ：包含联系类型和联系属性</p><ul><li>实体和实体之间发生的关联</li><li>一个实体一般都与一个或多个实体相关</li><li>类型：1对1联系（1 : 1）、1对多联系 (1 : N) 和多对多联系(M : N)</li></ul><p><img src="'+o+'" alt="image.png"></p><h3 id="_2-2-er设计步骤" tabindex="-1">2.2 ER设计步骤 <a class="header-anchor" href="#_2-2-er设计步骤" aria-label="Permalink to &quot;2.2 ER设计步骤&quot;">​</a></h3><p>自顶向下进行需求分析，自底向上进行ER设 计</p><h4 id="分er设计" tabindex="-1">分ER设计 <a class="header-anchor" href="#分er设计" aria-label="Permalink to &quot;分ER设计&quot;">​</a></h4><p>通过实体、联系和属性对子系统的数据进行 抽象，产生分ER图</p><p><strong>设计原则</strong></p><ul><li>实体要尽可能得少</li><li>现实世界中的事物若能作为属性就尽量作为属性 对待</li></ul><ol><li><strong>确定实体</strong></li></ol><ul><li>需求分析阶段产生的数据字典中的数据存储 、数据流和数据结构一般可以确定为实体</li><li><strong>数据字典</strong>五个部分：数据项、<strong>数据结构</strong>、<strong>数据流</strong>、<strong>数据存储</strong>和数据处理</li></ul><ol><li><strong>确定实体属性</strong></li></ol><ul><li>首先确定实体的码</li><li>属性应具有域</li><li>属性一般要满足下面的准则 <ul><li>属性必须不可分，不能包含其它属性</li><li>属性不能和其它实体具有联系</li></ul></li></ul><ol><li><strong>确定联系和联系属性</strong></li></ol><ul><li>根据数据需求的描述确定</li><li>确定联系的基数</li></ul><h4 id="er集成" tabindex="-1">ER集成 <a class="header-anchor" href="#er集成" aria-label="Permalink to &quot;ER集成&quot;">​</a></h4><ul><li>确定公共实体</li><li>合并分ER图</li><li>消除冲突（不是很理解） <ul><li>属性冲突：类型冲突、值冲突 <ul><li>例如性别、年龄</li></ul></li><li>结构冲突：实体属性集不同、联系类型不同、同 一对象在不同应用中的抽象不同</li><li>命名冲突：同名异义、异名同义 <ul><li>实体命名冲突、属性命名冲突、联系命名冲突</li></ul></li></ul></li></ul><p><img src="'+e+'" alt="image.png"></p><h4 id="er模型优化" tabindex="-1">ER模型优化 <a class="header-anchor" href="#er模型优化" aria-label="Permalink to &quot;ER模型优化&quot;">​</a></h4><p><strong>目标</strong>：实体个数要少，属性要少，联系尽量 无冗余（总的来说就是精简）</p><p><strong>合并实体</strong></p><ul><li>一般1:1联系的两个实体可以合并为一个实体</li><li>如果两个实体在应用中经常需要同时处理， 也可考虑合并 <ul><li>例如病人和病历，如果实际中通常是查看病人时 必然要查看病历，可考虑将病历合并到病人实体 中</li><li>减少了联接查询开销，提高效率</li></ul></li></ul><p><strong>消除冗余属性</strong></p><ul><li>分ER图中一般不存在冗余属性，但集成后可 能产生冗余属性（语义一样的属性，描述的是同一个东西）</li><li>例如，教育统计数据库中，一个分ER图中含有高 校毕业生数、在校学生数，另一个分ER图中含有 招生数、各年级在校学生数 。每个分ER图中没有冗余属性，但集成后“在校学 生数”冗余，应消除</li><li>冗余属性的几种情形 <ul><li>同一非码属性出现在几个实体中</li><li>一个属性值可从其它属性值中导出 ，例如出生日期和年龄</li></ul></li></ul><p><strong>消除冗余联系</strong></p><p>有点抽象，大概也是语义重复了就需要消除。</p><p><img src="'+n+'" alt="image.png"></p><h4 id="er模型扩展" tabindex="-1">ER模型扩展 <a class="header-anchor" href="#er模型扩展" aria-label="Permalink to &quot;ER模型扩展&quot;">​</a></h4><p><strong>弱实体</strong></p><p>一个弱实体的存在必须以另一实体的存在为 前提</p><ul><li>弱实体所依赖存在的实体称为常规实体（regular entity）或强实体（strong entity）</li><li>弱实体有自己的标识，但<strong>它的标识只保证对于所 依赖的强实体而言是唯一</strong>的。在<strong>整个系统中没有 自己唯一的实体标识</strong>（例如：账户为强实体，转账为弱实体，每一笔转账都有时间作为标识，但仅仅对特定一个账户是唯一的）</li></ul><p><img src="'+s+'" alt="image.png"></p><p><strong>子类（特殊化）和超类（一般化）</strong></p><ul><li>两个实体A和B并不相同，但实体A属于实体B， 则A称为实体子类，B称为实体超类</li><li>子类是超类的特殊化，超类是子类的一般化</li><li>子类继承了超类的全部属性，因此子类的标识就 是超类的标识，子类可以有自己的独有属性 <ul><li>例如，研究生是学生的子类，经理是职工的子类</li></ul></li></ul><p>在ER设计时，可以根据实际情况增加子类， 也可以根据若干实体抽象出超类</p><p><img src="'+u+'" alt="image.png"></p><h2 id="三、逻辑设计" tabindex="-1">三、逻辑设计 <a class="header-anchor" href="#三、逻辑设计" aria-label="Permalink to &quot;三、逻辑设计&quot;">​</a></h2><p><strong>主要内容</strong></p><p>根据概念模型设计出与DBMS支持的数据模 型相符合的数据库逻辑结构</p><ul><li>ER模型向关系模型的转换</li><li>关系模型优化</li><li>关系模型修正</li></ul><p><img src="'+p+'" alt="image.png"></p><h3 id="_3-1-基本er模型的转换" tabindex="-1">3.1 基本ER模型的转换 <a class="header-anchor" href="#_3-1-基本er模型的转换" aria-label="Permalink to &quot;3.1 基本ER模型的转换&quot;">​</a></h3><p><strong>实体转换</strong></p><ul><li>每个实体转换为一个关系模式</li><li>实体的属性为关 系模式的属性</li><li>实体的标识成为关系模式的主码</li></ul><p><strong>联系转换</strong></p><ul><li>1 : 1：将任一端的实体的标识和联系属性加入另一 实体所对应的关系模式中，两模式的主码保持不 变</li><li>1 : N：将1端实体的标识和联系属性加入N端实体 所对应的关系模式中，两模式的主码不变</li><li>M : N：新建一个关系模式，该模式的属性为两端 实体的标识以及联系的属性，主码为两端关系模 式的主码的组合</li></ul><h3 id="_3-2-扩展er模型的转换" tabindex="-1">3.2 扩展ER模型的转换 <a class="header-anchor" href="#_3-2-扩展er模型的转换" aria-label="Permalink to &quot;3.2 扩展ER模型的转换&quot;">​</a></h3><p><strong>弱实体转换</strong></p><ul><li>每个强实体像一般实体一样转换为一个关系模式</li><li>每个弱实体转换为一个关系模式，并加入所依赖 的强实体的标识，关系模式的主码为弱实体的标 识加上强实体的标识（账户+转账时间，唯一确定一笔转账）</li></ul><p><strong>子类转换</strong></p><ul><li>父类实体和子类实体都各自转换为关系模式，并 在子类关系模式中加入父类的主码，子类关系模 式的主码设为父类的主码</li></ul><h3 id="_3-3-模式的规范化" tabindex="-1">3.3 模式的规范化 <a class="header-anchor" href="#_3-3-模式的规范化" aria-label="Permalink to &quot;3.3 模式的规范化&quot;">​</a></h3><p><strong>1. 确定范式级别</strong></p><p>根据实际应用的需要（处理需求）确定要达到 的范式级别</p><p>时间效率和模式设计问题之间的权衡（主要考虑更新操作的多少）</p><ul><li><strong>范式越高，模式设计问题越少，但连接运算越多， 查询效率越低</strong></li><li>如果应用对数据只是查询，没有更新操作，则非 BCNF范式也不会带来实际影响</li><li>如果应用对数据更新操作较频繁，则要考虑高一级 范式以避免数据不一致</li><li>实际应用中一般以3NF为最高范式</li></ul><p><strong>2. 确定范式级别后，进行规范化处理</strong></p><h3 id="_3-4-模式评价" tabindex="-1">3.4 模式评价 <a class="header-anchor" href="#_3-4-模式评价" aria-label="Permalink to &quot;3.4 模式评价&quot;">​</a></h3><p>检查规范化后的数据库模式是否完全满足用 户需求，并确定要修正的部分</p><ul><li><strong>功能评价</strong>：检查数据库模式是否支持用户所有的 功能要求 <ul><li>必须包含用户要存取的所有属性</li><li>如果某个功能涉及多个模式，要保证无损连接性</li></ul></li><li><strong>性能评价</strong>：检查<strong>查询响应时间</strong>是否满足规定的需 求。 <ul><li>由于模式分解导致连接代价</li><li>如果不满足，要重新考虑模式分解的适当性</li><li>可采用模拟的方法评价性能</li></ul></li></ul><h3 id="_3-5-模式修正" tabindex="-1">3.5 模式修正 <a class="header-anchor" href="#_3-5-模式修正" aria-label="Permalink to &quot;3.5 模式修正&quot;">​</a></h3><p>根据模式评价的结果，对已规范化的数据 库模式进行修改</p><ul><li>若<strong>功能</strong>不满足，则要增加关系模式或属性</li><li>若<strong>性能</strong>不满足，则要考虑 <ul><li>逆规范化</li><li>分库分表</li><li>使用存储过程</li><li>缓存加速</li></ul></li></ul><p><strong>优化策略（提升性能，不是改善功能）</strong></p><ul><li>逆规范化：模式合并，增加冗余属性</li><li>分库分表 <ul><li>横向切分数据（冷热数据划分）</li><li>纵向分解模式（其实就是模式分解，常用的属性单独划分为一个模式，或者一些重复值多的属性划分出去）</li></ul></li></ul><p><img src="'+g+'" alt="image.png"></p><p><img src="'+c+'" alt="image.png"></p><ul><li>使用存储过程 <ul><li>客户在服务器上存储一个写好的程序</li><li>可以在前端程序中调用，将数据密集型任务交给数据库服务 器完成</li></ul></li></ul><p><img src="'+d+'" alt="image.png"></p><ul><li>缓存加速 <ul><li>Redis</li><li>Memached</li></ul></li></ul><h3 id="_3-6-设计用户子模式-视图" tabindex="-1">3.6 设计用户子模式（视图） <a class="header-anchor" href="#_3-6-设计用户子模式-视图" aria-label="Permalink to &quot;3.6 设计用户子模式（视图）&quot;">​</a></h3><ul><li>使用更符合用户习惯的<strong>别名</strong><ul><li>ER图集成时要消除命名冲突以保证关系和属性名的唯一 ，在子模式设计时可以重新定义这些名称，以符合用户习 惯</li></ul></li><li>给不同级别的用户定义不同的子模式，以保证系统<strong>安全性</strong><ul><li>产品(产品号，产品名，规格，单价，产品成本，产品合 格率)</li><li>为一般顾客建立子模式：产品1(产品号，产品名，规格，单价）</li><li>为销售部门建立：产品2(产品号，名称，规格，单价，成本，合 格率)</li></ul></li><li>简化用户程序对系统的使用 <ul><li>可将某些复杂查询设计为子模式以方便使用</li></ul></li></ul><h2 id="四、数据库物理设计" tabindex="-1">四、数据库物理设计 <a class="header-anchor" href="#四、数据库物理设计" aria-label="Permalink to &quot;四、数据库物理设计&quot;">​</a></h2><ul><li>设计数据库的物理结构 <ul><li>为关系模式选择存取方法</li><li>设计数据库的存储结构</li></ul></li><li>物理设计的考虑 <ul><li>查询时间效率</li><li>存储空间</li><li>维护代价</li></ul></li><li>物理设计依赖于给定的计算机系统</li></ul><p><strong>选择存取方法</strong></p><ul><li>存取方法：数据的存取路径 <ul><li>例如图书查询</li></ul></li><li>存取方法的选择目的是加快数据存取的速度 <ul><li>索引存取方法</li><li>聚簇存取方法</li><li>散列存取方法</li></ul></li></ul><p><strong>设计存储结构</strong></p><ul><li>针对应用环境和DBMS特性，合理安排数据<strong>存储 位置</strong><ul><li>表和索引可考虑放在不同的磁盘上，使查询时可以并行 读取</li><li>日志文件和备份文件由于数据量大，而且只有恢复时使 用，可放到磁带上</li></ul></li><li>确定<strong>系统配置</strong><ul><li>系统初始参数不一定适合应用并发用户数、同时打开的数据库对象数、缓冲区分配参 数、物理块的大小等</li></ul></li></ul><h2 id="五、数据库实施" tabindex="-1">五、数据库实施 <a class="header-anchor" href="#五、数据库实施" aria-label="Permalink to &quot;五、数据库实施&quot;">​</a></h2><p><img src="'+h+'" alt="image.png"></p><h2 id="六、数据库维护" tabindex="-1">六、数据库维护 <a class="header-anchor" href="#六、数据库维护" aria-label="Permalink to &quot;六、数据库维护&quot;">​</a></h2><p><img src="'+b+'" alt="image.png"></p>',94),f=[m];function q(E,R,P,x,k,B){return a(),i("div",null,f)}const S=l(_,[["render",q]]);export{N as __pageData,S as default};
