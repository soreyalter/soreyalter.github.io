import{_ as a,D as o,c as t,j as l,a as i,I as r,a4 as c,o as n}from"./chunks/framework.BGthqKqN.js";const d="/adb/chap11/1.jpg",s="/adb/chap11/2.jpg",u="/adb/chap11/3.jpg",p="/adb/chap11/4.jpg",h="/adb/chap11/5.jpg",g="/adb/chap11/6.jpg",m="/adb/chap11/7.jpg",X=JSON.parse('{"title":"Chap11. 并发控制","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"courseNotes/adb/c11concurrencyControl.md","filePath":"courseNotes/adb/c11concurrencyControl.md"}'),b={name:"courseNotes/adb/c11concurrencyControl.md"},k={id:"chap11-并发控制",tabindex:"-1"},I=l("a",{class:"header-anchor",href:"#chap11-并发控制","aria-label":'Permalink to "Chap11. 并发控制<Badge type="info" text="beta" />"'},"​",-1),_=c('<div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>本章内容未完成，ppt截图和笔记还没整理完毕</p></div><h2 id="i-motivation-and-problem" tabindex="-1">I.Motivation and Problem <a class="header-anchor" href="#i-motivation-and-problem" aria-label="Permalink to &quot;I.Motivation and Problem&quot;">​</a></h2><p>并发操作可能带来什么问题？ 并发操作使多个事务之间可能产生相互干扰，破坏事务的隔离性（Isolation）</p><h3 id="丢失更新-lost-update" tabindex="-1">丢失更新（Lost update） <a class="header-anchor" href="#丢失更新-lost-update" aria-label="Permalink to &quot;丢失更新（Lost update）&quot;">​</a></h3><ul><li>两次提交写导致的写覆盖</li></ul><p><img src="'+d+'" alt="img1"></p><h3 id="脏读-dirty-read-uncommitted-update" tabindex="-1">脏读（Dirty read / Uncommitted update） <a class="header-anchor" href="#脏读-dirty-read-uncommitted-update" aria-label="Permalink to &quot;脏读（Dirty read / Uncommitted update）&quot;">​</a></h3><ul><li>脏读是指一个事务读取了另一个事务还未提交的数据，当另一个事务回滚时，读取该数据的事务将读取到错误的数据。因为write会写到buffer中，而read首先检查buffer有没有才会去读磁盘</li><li>由于Rollback导致的提交事务的写失效破坏了其他事务的原子性</li><li>DBMS中不允许出现Dirty write 在任何情况下都要求X锁保留到事务结束（严格二阶段锁）</li><li>脏数据：事务在内存中更新了但还未最终提交的数据</li></ul><p><img src="'+s+'" alt="img1"></p><h3 id="不一致分析-inconsistent-analysis" tabindex="-1">不一致分析（Inconsistent analysis） <a class="header-anchor" href="#不一致分析-inconsistent-analysis" aria-label="Permalink to &quot;不一致分析（Inconsistent analysis）&quot;">​</a></h3><p>事务<u>读了过时的数据</u>，不是数据库的当前状态</p><ul><li><strong>不可重复读 Nonrepeatable read</strong>：事务内读的数据被其它事务update或者delete了 <ul><li>比如事务T专门用于求总和，在执行过程中关系内insert了一条记录，那么事务T得到的结果就是不准确的</li></ul></li><li><strong>幻像读 Phantom read</strong>：事务内读到的数据内容被其它事务的insert操作改变了</li></ul><h2 id="ii-可串性的概念" tabindex="-1">II. 可串性的概念 <a class="header-anchor" href="#ii-可串性的概念" aria-label="Permalink to &quot;II. 可串性的概念&quot;">​</a></h2><p><strong>可串化调度Serialzable Schedule</strong>：如果一个调度的结果与某一串行调度执行的结果等价，则称该调度是可串化调度，否则是不可串调度 <strong>冲突操作</strong></p><ul><li>如果调度中一对连续操作是冲突的，则意味着如果它们的执行顺序交换，则至少会改变其中一个事务的最终执行结果</li><li>如果两个<u>连续操作不冲突，则可以在调度中交换顺序</u></li></ul><p><img src="'+u+'" alt="img1"></p><h2 id="iii-冲突可串性及其判定方法" tabindex="-1">III. 冲突可串性及其判定方法* <a class="header-anchor" href="#iii-冲突可串性及其判定方法" aria-label="Permalink to &quot;III. 冲突可串性及其判定方法*&quot;">​</a></h2><p>冲突可串性</p><ul><li><strong>冲突等价</strong>: 如果调度S1,S2可以通过一系列非冲突的操作交换得到,则称这两个调度冲突等价</li><li><strong>冲突可串性</strong>: 如果一个调度与串行调度冲突等价,则称这个调度满足冲突可串性（通过交换可以变成串行调度）</li><li><strong>定理</strong><ul><li>如果一个调度满足冲突可串性,则该调度为可串化调度</li><li>给定一个调度S，构造S的优先图P(S)，若P(S)中无环，则S满足冲突可串性</li></ul></li></ul><h2 id="iv-锁的相关概念-s、x、u、is、ix等" tabindex="-1">IV. 锁的相关概念：S、X、U、IS、IX等 <a class="header-anchor" href="#iv-锁的相关概念-s、x、u、is、ix等" aria-label="Permalink to &quot;IV. 锁的相关概念：S、X、U、IS、IX等&quot;">​</a></h2><p><strong>X锁（Exclusive Locks）</strong>：也称作写锁，排它锁。若事务T对数据R加X锁，那么其它事务要等T释放X锁以后，才能获准对数据R进行封锁。只有获得R上的X锁的事务，才能对所封锁的数据进行修改</p><p><strong>S锁（Share Locks）</strong>：也称读锁。</p><ul><li>如果事务 T 对数据 R 加了 S 锁，则其它事务对 R 的X锁请求不能成功，但对 R 的 S 锁请求可以成功。这就保证了其它事务可以读取 R 但不能修改 R ，直到事务 T 释放 S 锁。</li><li>当事务获得 S 锁后，如果要对数据 R 进行修改，则必须在修改前执行Upgrade(R)操作，将 S 锁升级为X锁（Update Lock）</li></ul><p><strong>U锁（Update Lock）：能升级的读锁</strong></p><ul><li>如果事务取得了数据R上的更新锁，则可以读R，并且可以在以后升级为 X 锁</li><li>单纯的S锁不能升级为 X 锁</li><li>如果事务持有了 R 上的 Update Lock，则其它事务不能得到 R 上的 S 锁、X 锁以及 Update 锁（排他）</li><li>如果事务持有了 R 上的 S Lock，则其它事务可以获取 R 上的 Update Lock</li></ul><p>**IS锁（Intent Share Lock）**意向共享锁，意向读锁</p><ul><li>如果对某个结点加 IS(IX)锁，则说明事务要对该结点的某个下层结点加S (X)锁；</li><li>对任一结点 P 加 S(X)锁，必须先对从【根结点到 P 的路径】上的所有结点加 IS(IX)锁</li></ul><p>**IX锁（Intent Exclusive Lock）**意向排它锁，意向写锁</p><h2 id="v-2pl-的含义-如何使用-2pl-保证并发事务的可串行性" tabindex="-1">V. 2PL 的含义？如何使用 2PL 保证并发事务的可串行性？ <a class="header-anchor" href="#v-2pl-的含义-如何使用-2pl-保证并发事务的可串行性" aria-label="Permalink to &quot;V. 2PL 的含义？如何使用 2PL 保证并发事务的可串行性？&quot;">​</a></h2><p>2PL 两阶段锁协议</p><ul><li>如果一个调度S中的所有事务都是两段式事务，则该调度是可串化调度</li></ul><p><img src="'+p+'" alt="img1"></p><h2 id="vi-事务的隔离级别" tabindex="-1">VI. 事务的隔离级别* <a class="header-anchor" href="#vi-事务的隔离级别" aria-label="Permalink to &quot;VI. 事务的隔离级别*&quot;">​</a></h2><ul><li><strong>Insight 1</strong>：隔离级别是<u>针对连接（会话）而设置的，不是针对一个事务</u></li><li><strong>Insight 2</strong>：不同隔离级别影响<u>读操作</u></li></ul><p><img src="'+h+'" alt="img1"></p><h3 id="未提交读-脏读-read-uncommitted" tabindex="-1">未提交读（脏读） Read Uncommitted <a class="header-anchor" href="#未提交读-脏读-read-uncommitted" aria-label="Permalink to &quot;未提交读（脏读） Read Uncommitted&quot;">​</a></h3><ul><li>允许读取当前数据页上的任何数据，不管数据是否已提交（随便读）</li><li>事务不必等待任何锁，也不对读取的数据加锁（没有锁机制）</li></ul><p><img src="'+g+'" alt="img1"></p><h3 id="提交读" tabindex="-1">提交读 <a class="header-anchor" href="#提交读" aria-label="Permalink to &quot;提交读&quot;">​</a></h3><ul><li>保证事务不会读取到其他未提交事务所修改的数据（可防止脏读）</li><li>事务必须在所访问数据上加S锁，数据一旦读出，就马上释放持有的锁</li></ul><h3 id="可重复读" tabindex="-1">可重复读 <a class="header-anchor" href="#可重复读" aria-label="Permalink to &quot;可重复读&quot;">​</a></h3><ul><li>保证事务在事务内部如果重复访问同一数据（记录集），数据不会发生改变。即，事务<u>在访问数据时，其他事务不能修改正在访问的那部分数据</u></li><li>可重复读可以防止脏读和不可重复读取，但不能防止幻像</li><li>事务必须在所访问数据上加 S 锁，防止其他事务修改数据，而且<strong>S锁必须保持到事务结束</strong></li></ul><p><img src="'+m+'" alt="img1"></p><h3 id="可串化" tabindex="-1">可串化 <a class="header-anchor" href="#可串化" aria-label="Permalink to &quot;可串化&quot;">​</a></h3><ul><li>保证事务调度是可串化的</li><li><u>事务在访问数据时，其他事务<strong>不能修改</strong>数据，也<strong>不能插入</strong>新元组</u></li><li>事务必须在所访问数据上加S锁，防止其他事务修改数据，而且<u>S锁必须保持到事务结束</u></li><li>事务还<u>必须锁住访问的整个表（表锁）</u></li><li>不会出现丢失更新</li></ul><h2 id="vii-死锁" tabindex="-1">VII. 死锁* <a class="header-anchor" href="#vii-死锁" aria-label="Permalink to &quot;VII. 死锁*&quot;">​</a></h2><ul><li>已持有锁并互相请求对方的锁（或者多个事务请求组成了环）</li><li>两个事务同时想要升级写锁为 X 锁（另一个事务的 S 锁与 X 锁互斥，无法升级）</li></ul><h3 id="死锁检测-deadlock-detecting" tabindex="-1">死锁检测 Deadlock Detecting <a class="header-anchor" href="#死锁检测-deadlock-detecting" aria-label="Permalink to &quot;死锁检测 Deadlock Detecting&quot;">​</a></h3><ul><li><strong>超时机制</strong><ul><li>事务超过时间没完成就Abort</li></ul></li><li><strong>等待图</strong><ul><li><code>Ti</code> → <code>Tj</code>，表示<code>Ti</code>必须等待<code>Tj</code>释放所持有的某个锁才能继续执行</li><li>有环表示产生了死锁</li></ul></li></ul><h3 id="死锁预防-deadlock-prevention" tabindex="-1">死锁预防 Deadlock Prevention <a class="header-anchor" href="#死锁预防-deadlock-prevention" aria-label="Permalink to &quot;死锁预防 Deadlock Prevention&quot;">​</a></h3><ul><li><p><strong>按序加锁 Priority Order</strong></p><ul><li>把要加锁的数据库元素按某种顺序排序</li><li>事务只能按照元素顺序申请锁</li></ul></li><li><p><strong>时间戳 Timestamp</strong></p><ul><li>每个事务开始时赋予一个时间戳</li><li>如果事务<code>T</code>被Rollback然后再Restart，<u><code>T</code>的时间戳不变</u></li><li><code>Ti</code>请求被<code>Tj</code>持有的锁，<u>根据<code>Ti</code>和<code>Tj</code>的timestamp决定锁的授予</u></li></ul></li></ul><p><strong>Wait-Die Scheme 等待－死亡</strong></p><p><code>T</code>请求一个被U持有的锁</p><ul><li>若<code>T</code>更早开始，等待<code>U</code>释放锁</li><li>若<code>T</code>更晚才开始，DIE并等待被重新调度，时间戳不变</li></ul><p><strong>Wound-Wait Scheme 伤害－等待</strong></p><p><code>T</code>请求一个被<code>U</code>持有的锁</p><ul><li>若<code>T</code>更早开始，<code>T</code>抢夺<code>U</code>的锁，<code>U</code> rollback 等待重新开始</li><li>若<code>T</code>更晚才开始，等待<code>U</code>释放锁</li></ul><p><strong>两种方式比较</strong></p><ul><li>Wait-Die: RB次数多，但每次RB开销小 <ul><li>Rollback 总是发生在请求锁阶段，因此要 Rollback 的事务操作比较少，但 Rollback 的事务数会比较多</li></ul></li><li>Wound-Wait: RB 次数少，但每次 RB 开销大 <ul><li>发生 Rollback 时，要 Rollback 的事务已经获得了锁，有可能已经执行了较长时间，因此 Rollback 的事务操作会较多，但 Rollback 的事务数预期较少，因为可以假设事务开始时总是先请求锁</li><li>请求锁时 WAIT 要比 WOUND 要更普遍，因为一般情况下一个新事务要请求的锁总是被一个较早的事务所持有</li></ul></li></ul><h2 id="viii-乐观并发控制技术" tabindex="-1">VIII. 乐观并发控制技术 <a class="header-anchor" href="#viii-乐观并发控制技术" aria-label="Permalink to &quot;VIII. 乐观并发控制技术&quot;">​</a></h2><p><strong>适用场景</strong>：如果大部分事务都是只读事务，则并发冲突的概率比较低；即使不加锁，也不会破坏数据库的一致性；加锁反而会带来事务延迟</p><p><strong><u>“读不加锁，写时协调”</u></strong></p><ul><li>基于事后协调冲突的思想，用户访问数据时不加锁；如果发生冲突，则通过回滚某个冲突事务加以解决</li><li>使用“有效性确认(Validation)”确定哪些事务发生冲突</li></ul><p><strong>有效性确认协议</strong></p><p>每个更新事务<code>Ti</code>在其生命周期中按以下三个阶段顺序执行</p><ul><li>读阶段：数据被读入到事务<code>Ti</code>的局部变量中。此时所有write操作都针对局部变量，并不对数据库更新</li><li>有效性确认阶段：<code>Ti</code>进行有效性检查，判定<u>是否可以将write操作所更新的局部变量值写回数据库而不违反可串性</u><ul><li>基于行版本检查（时间戳）</li><li>基于值比较检查</li></ul></li><li>写阶段：若<code>Ti</code>通过有效性检查，则进行实际的写数据库操作，否则回滚<code>Ti</code></li></ul>',66);function S(P,T,q,R,f,x){const e=o("Badge");return n(),t("div",null,[l("h1",k,[i("Chap11. 并发控制"),r(e,{type:"info",text:"beta"}),i(),I]),_])}const U=a(b,[["render",S]]);export{X as __pageData,U as default};
