import{_ as a,c as l,o as e,a4 as o}from"./chunks/framework.BGthqKqN.js";const i="/adb/chap4/d0ea177b6c1988f7c4896b60bd9f39cd.png",t="/adb/chap4/8f0bf29d9e6bbf7c077027fae61f17b1.png",r="/adb/chap4/94a1ad49ebfdc91edeed9d0204edb1c2.png",n="/adb/chap4/11023a480cfdaa0a30515d7ef08c255a.png",f=JSON.parse('{"title":"数据的存储","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"courseNotes/adb/c4dataStorage.md","filePath":"courseNotes/adb/c4dataStorage.md"}'),s={name:"courseNotes/adb/c4dataStorage.md"},p=o('<h1 id="数据的存储" tabindex="-1">数据的存储 <a class="header-anchor" href="#数据的存储" aria-label="Permalink to &quot;数据的存储&quot;">​</a></h1><blockquote><p>1、磁盘块存取时间*</p><p>2、存储器结构</p><p>3、不同类型存储介质之间的差异</p></blockquote><h2 id="如何读下一块" tabindex="-1">如何读下一块 <a class="header-anchor" href="#如何读下一块" aria-label="Permalink to &quot;如何读下一块&quot;">​</a></h2><ul><li><strong>下一块在同一柱面</strong></li><li>Sequential I/O</li><li>旋转 + 传输 + 其他（忽略）</li><li><strong>不在一个柱面</strong></li><li>Ramdom I/O</li><li>寻道 + 旋转 + 传输 + 其他</li></ul><h2 id="写块" tabindex="-1">写块 <a class="header-anchor" href="#写块" aria-label="Permalink to &quot;写块&quot;">​</a></h2><ul><li>与读块类似</li><li>如果需要校验块是否正确写入，则需要加上一 次旋转时间和一次块传输时间（读出来一次Sequential I/O）</li></ul><h2 id="随机读一块的时间" tabindex="-1">随机读一块的时间 <a class="header-anchor" href="#随机读一块的时间" aria-label="Permalink to &quot;随机读一块的时间&quot;">​</a></h2><p>计算公式：T = S + R + T</p><ul><li><strong>最大时间</strong></li><li>S 最大寻道时间</li><li>R 最大旋转延迟（旋转一周的时间）</li><li>T 传输延时</li><li><strong>最小时间</strong></li><li>S = R = 0（不用寻道也不用旋转，说明要读的块就是当前位置的下一块）</li><li><strong>平均时间</strong></li><li>S 平均寻道延时（注意，是最大寻道时间 1 / 3 而不是1/2）</li></ul><h2 id="磁盘存取优化" tabindex="-1">磁盘存取优化 <a class="header-anchor" href="#磁盘存取优化" aria-label="Permalink to &quot;磁盘存取优化&quot;">​</a></h2><p><img src="'+i+'" alt="image.png"></p><h3 id="random-io-to-sequential-io" tabindex="-1">Random IO to Sequential IO <a class="header-anchor" href="#random-io-to-sequential-io" aria-label="Permalink to &quot;Random IO to Sequential IO&quot;">​</a></h3><p>通过I/O调度重排请求序列，MySQL InnoDB 则利用事务日志把随机I/O转成顺序I/O</p><p><img src="'+t+'" alt="image.png"></p><h3 id="预取-缓冲" tabindex="-1">预取 / 缓冲 <a class="header-anchor" href="#预取-缓冲" aria-label="Permalink to &quot;预取 / 缓冲&quot;">​</a></h3><p><strong>双缓冲处理时间</strong></p><ul><li>R＋nP（P&gt;=R）</li><li>nR＋P（R&gt;=P）</li></ul><p><strong>单缓冲处理时间</strong></p><ul><li>n(R + P)</li></ul><p><strong>缓冲代价</strong></p><ul><li>主存代价</li><li>缓冲区管理</li><li>一致性维护</li></ul><h2 id="新型存储" tabindex="-1">新型存储 <a class="header-anchor" href="#新型存储" aria-label="Permalink to &quot;新型存储&quot;">​</a></h2><p>计算机系统性能依赖于</p><ul><li>处理器的数据计算能力</li><li><u>存储层次向处理器传输数据的能力</u></li></ul><p>随着多\\众核、多线程技术的发展，传统存储器件构成的存储层次面临 的存储墙问题愈发严重</p><ul><li>处理单元（核）数的增长与存储数据供应能力（容量）不匹配</li><li>SRAM\\DRAM的功耗过高</li></ul><p>新型存储器件包括：闪存、相变存储器、磁阻式存储、电阻式存储器 、忆阻器等等。具备一个共同特点：<strong>非易失性</strong></p><ul><li>优点：高存储密度、低功耗、无机械延迟、存取速度快、便携、抗震、低 噪音等</li><li>缺点：读写性能不对称、读写次数有限、可靠性不高等</li></ul><h3 id="闪存-flash-memory" tabindex="-1">闪存 Flash Memory <a class="header-anchor" href="#闪存-flash-memory" aria-label="Permalink to &quot;闪存 Flash Memory&quot;">​</a></h3><p>闪存 = 闪存芯片 + 控制器 +FTL（翻译层）</p><p><strong>闪存（NAND）的特点</strong></p><ol><li><p>读写不对称:写慢读快</p></li><li><p>写前擦除:异位更新、块擦除操作</p></li><li><p>寿命有限：块擦除次数有限</p></li></ol><blockquote><p>SLC （约10万次擦写） MLC（小于1万次） TLC（小于1000次）</p></blockquote><ol start="4"><li>按页读写</li></ol><blockquote><p>1 page =2 KB</p></blockquote><ol start="5"><li>按块擦除</li></ol><blockquote><p>1 block = 64 pages</p></blockquote><p><strong>闪存数据库面临的挑战</strong></p><p><img src="'+r+'" alt="image.png"></p><h3 id="相变存储器-phase-change-memory" tabindex="-1">相变存储器 Phase Change Memory <a class="header-anchor" href="#相变存储器-phase-change-memory" aria-label="Permalink to &quot;相变存储器 Phase Change Memory&quot;">​</a></h3><ul><li>电阻式非易失性半导体存储器</li><li>以硫族化物材料作为存储介质，利用相变材料在不同结 晶状态时呈现出显著的电阻值差异性来实现数据存储</li></ul><p><strong>PCM vs. Flash</strong></p><p>看起来读写性能和寿命PCM都更好</p><p><img src="'+n+'" alt="image.png"></p>',44),c=[p];function h(d,u,g,m,b,_){return e(),l("div",null,c)}const P=a(s,[["render",h]]);export{f as __pageData,P as default};
