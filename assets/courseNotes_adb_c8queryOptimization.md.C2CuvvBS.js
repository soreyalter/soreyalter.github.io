import{_ as a,c as t,o as e,a4 as i}from"./chunks/framework.BBKq6QKo.js";const r="/adb/chap8/36b8aeb8207126e88e71803ba5a0be8f.png",o="/adb/chap8/eb3a327dcc05b4c40fd0155b8d781d6d.png",l="/adb/chap8/7c5b32a61a75d62f144dcfe904c7e6fb.png",n="/adb/chap8/51fdbbc579286031236dbc432a997332.png",s="/adb/chap8/bfd7f2458c96be7e7453858ddc7350b0.png",p="/adb/chap8/f51aa09412d82a8514759405792ee9d6.png",c="/adb/chap8/62d8ca280e2497404132bbd8f8888410.png",d="/adb/chap8/7cf1fadbb3c763de60a8a7317ccf219b.png",h="/adb/chap8/cff4019831305e31cbad2f272762eb89.png",O=JSON.parse('{"title":"查询优化","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"courseNotes/adb/c8queryOptimization.md","filePath":"courseNotes/adb/c8queryOptimization.md"}'),g={name:"courseNotes/adb/c8queryOptimization.md"},b=i('<h1 id="查询优化" tabindex="-1">查询优化 <a class="header-anchor" href="#查询优化" aria-label="Permalink to &quot;查询优化&quot;">​</a></h1><blockquote><p>复习提纲</p><p>1、查询处理器的工作过程</p><p>2、关系代数与SQL之间的关系</p><p><strong>3、中间结果大小估计*</strong></p><p>4、I/O代价的影响因素</p></blockquote><h2 id="查询流程" tabindex="-1">查询流程 <a class="header-anchor" href="#查询流程" aria-label="Permalink to &quot;查询流程&quot;">​</a></h2><p><img src="'+r+'" alt="image.png"></p><p>SQL查询 &lt;=&gt; 关系代数表达式（逻辑查询计划）</p><p><strong>逻辑查询计划树</strong></p><ul><li>叶结点 = 关系</li><li>非叶结点 = 关系运算符</li></ul><p><img src="'+o+'" alt="image.png"></p><h2 id="查询重写——重写逻辑查询计划" tabindex="-1">查询重写——重写逻辑查询计划 <a class="header-anchor" href="#查询重写——重写逻辑查询计划" aria-label="Permalink to &quot;查询重写——重写逻辑查询计划&quot;">​</a></h2><p>基于关系代数转换规则：自然连接、并、交、笛卡尔积<strong>交换律和结合律</strong></p><p><img src="'+l+'" alt="image.png"></p><p><img src="'+n+'" alt="image.png"></p><p><strong>转换的目的</strong></p><p><img src="'+s+'" alt="image.png"></p><h2 id="中间代价估计" tabindex="-1">中间代价估计（*） <a class="header-anchor" href="#中间代价估计" aria-label="Permalink to &quot;中间代价估计（\\*）&quot;">​</a></h2><p><img src="'+p+'" alt="image.png"></p><h3 id="选择操作的估计" tabindex="-1">选择操作的估计 <a class="header-anchor" href="#选择操作的估计" aria-label="Permalink to &quot;选择操作的估计&quot;">​</a></h3><p><img src="'+c+'" alt="image.png"></p><p><img src="'+d+'" alt="image.png"></p><h3 id="连接操作的估计" tabindex="-1">连接操作的估计 <a class="header-anchor" href="#连接操作的估计" aria-label="Permalink to &quot;连接操作的估计&quot;">​</a></h3><p><strong>case1</strong>：两个关系无公共属性，代价 = 笛卡尔积</p><p><strong>case2</strong>：有一个公共属性</p><ul><li>T~值集的包含</li><li>V~值集的保持</li></ul><p><img src="'+h+'" alt="image.png"></p><h3 id="i-o代价估计" tabindex="-1">I/O代价估计 <a class="header-anchor" href="#i-o代价估计" aria-label="Permalink to &quot;I/O代价估计&quot;">​</a></h3><h4 id="影响查询计划i-o代价的因素" tabindex="-1">影响查询计划I/O代价的因素 <a class="header-anchor" href="#影响查询计划i-o代价的因素" aria-label="Permalink to &quot;影响查询计划I/O代价的因素&quot;">​</a></h4><ul><li><strong>实现查询计划的逻辑操作符</strong><ul><li>在选择逻辑查询计划时已确定</li></ul></li><li><strong>中间结果的大小</strong></li><li><strong>实现逻辑操作符的物理操作符</strong><ul><li>例如，连接操作是用索引连接还是散列连接？</li></ul></li><li><strong>相似操作的顺序</strong><ul><li>例如，多关系的连接顺序</li></ul></li><li><strong>物理操作符之间的参数传递方式</strong><ul><li>Pipeline（流水线）还是Materization（物化）？</li></ul></li></ul><h4 id="物理操作符之间的参数传递" tabindex="-1">物理操作符之间的参数传递 <a class="header-anchor" href="#物理操作符之间的参数传递" aria-label="Permalink to &quot;物理操作符之间的参数传递&quot;">​</a></h4><p><strong>物化方式</strong></p><ul><li>操作依次执行，并且每个操作的结果（中间关系）都写到磁盘上供其它操作存取</li><li>通过磁盘物理进行数据传递</li><li>节省主存空间</li></ul><p><strong>流水线</strong></p><ul><li>多个操作同时执行，一个操作产生的元组直接通过<strong>共 享内存</strong>传递给其它操作</li><li>节省I/O</li><li>但占用主存，若缓冲区出现“颠簸”则I/O增加</li></ul><h2 id="乱七八糟" tabindex="-1">乱七八糟 <a class="header-anchor" href="#乱七八糟" aria-label="Permalink to &quot;乱七八糟&quot;">​</a></h2><h3 id="执行计划的缓存和重用" tabindex="-1">执行计划的缓存和重用 <a class="header-anchor" href="#执行计划的缓存和重用" aria-label="Permalink to &quot;执行计划的缓存和重用&quot;">​</a></h3><ul><li>在 MS SQL Server 中执行任何 SQL 语句 时，关系引擎将首先<strong>查看缓存中是否有用于 同一 SQL 语句的现有执行计划</strong>。MS SQL Server 重新使用所找到的任何现有计划以 节省重新编译 SQL 语句的开销。</li><li>如果没有现有执行计划，则 MS SQL Server 将为查询生成新的执行计划。</li></ul>',35),u=[b];function m(_,f,q,S,P,k){return e(),t("div",null,u)}const I=a(g,[["render",m]]);export{O as __pageData,I as default};
